{
package main

func toSlice[T any](v any) []T {
  if v == nil {
    return nil
  }

  originalSlice := v.([]any)
  newSlice := make([]T, len(originalSlice))

  for i, val := range originalSlice {
    newSlice[i] = val.(T)
  }

  return newSlice
}

}


Input <- lines:Line* EOF {
  outLines := make([]any, 0, len(lines.([]any)))

  for _, line := range lines.([]any) {
    if line == nil {
      continue
    }

    outLines = append(outLines, line)
  }

  return Lines{outLines}, nil
}


EOF <- !.
White <- [ \t\r\n]* // includes newlines
Space <- [ \t]*
SomeSpace <- [ \t]+
Break <- "\r"? "\n"
Stop <- Break / EOF
SpaceStop <- Space Stop
AlphaNum <- [a-zA-Z0-9_]

// A Line mathes the end of the line and advances to the next line
Line <- EmptyLine / CommentLine / AssignmentLine / IfStatement / ExpressionLine

Keyword <- "if" / "then" / "elseif" / "else"

EmptyLine <- (Space Break / [ \t]+ Stop) {
  return nil, nil
}

ExpressionLine <- value:Expression Stop {
  return value, nil
}

Expression <- head:ExpressionValue rest:OperatorExpression* {
  r := make([]OperatorExpressionNode, 0, len(rest.([]any)))

  for _, exp := range rest.([]any) {
    r = append(r, exp.(OperatorExpressionNode))
  }

  // remove unec
  if len(r) == 0 {
    return head, nil
  }

  return ExpressionNode{head, r}, nil
}

OperatorExpression <- Space operator:Operator White exp:ExpressionValue {
  return OperatorExpressionNode{operator.(string), exp}, nil
}

ExpressionValue <- Primitive / Number / Chain / Ref / String / Table / Parens

Parens <- "(" White exp:Expression White ")" {
  return ParensNode{exp}, nil
}

ExpressionList <- head:Expression tail:ExpressionListTail* {
  exprs := make([]any, 0, 1)
  exprs = append(exprs, head)
  for _, t := range tail.([]any) {
    exprs = append(exprs, t)
  }

  return exprs, nil
}

ExpressionListTail <- Space "," White expr:Expression {

  return expr, nil
}

Operator <- ([-+*/^%<>] / WordOperator) {
  return string(c.text), nil
}

WordOperator <- ("and" / "or") !AlphaNum / ".."

AssignmentLine <- names:NameList White "=" White exprs:ExpressionList Stop {
  return AssignmentNode{names.([]any), exprs.([]any)}, nil
}

Comment <- "--" body:CommentBody {
  return CommentNode{body.(string)}, nil
}

// a comment that takes up an entire line
CommentLine <- Space value:Comment Stop {
  return value, nil
}

CommentBody <- (!Break .)* {
  return string(c.text), nil
}

Name <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

NameListTail <- Space "," White name:Name {
  return name, nil
}

NameList <- head:Name tail:NameListTail* {
  names := make([]any, 0, 1)
  names = append(names, head)
  for _, t := range tail.([]any) {
    names = append(names, t)
  }

  return names, nil
}

Ref <- !Keyword name:Name {
  return RefNode{name.(string)}, nil
}

// TODO: handle decimals and exponents (non integer types
Number <- [0-9]+ {
  return NumberNode{Integer, string(c.text)}, nil
}

String <- DoubleQuotedString / SingleQuotedString / LuaString

DoubleQuotedString <- '"' parts:(Interpolation / DoubleStringChars)* '"' {
  return StringNode{`"`, parts.([]any)}, nil
}

DoubleStringChars <- ([\\] '"' / !["] !"#{" .)+ {
  return string(c.text), nil
}

Interpolation <- "#{" expr:Expression "}" {
  return InterpolationNode{expr}, nil
}

SingleQuotedString <- "'" parts:(SingleStringChars)* "'" {
  return StringNode{`'`, parts.([]any)}, nil
}

SingleStringChars <- ([\\] "'" / !"'" .)+ {
  return string(c.text), nil
}

LuaString <- LuaStringOpen parts:(LuaStringChars)* LuaStringClose {
  return StringNode{"XXX", parts.([]any)}, nil
}

LuaStringChars <- (!LuaStringClose .)+ {
  return string(c.text), nil
}

LuaStringDelimiterCount <- "="* {
  return len(c.text), nil
}

LuaStringOpen <- "[" count:LuaStringDelimiterCount "[" #{
  c.state["lua_string"] = count
  return nil
}

LuaStringClose <- "]" count:LuaStringDelimiterCount "]" &{
  if c.state["lua_string"].(int) == count.(int) {
    return true, nil
  }

  return false, nil
}

Primitive <- ("true" / "false" / "nil") {
  return PrimitiveNode{string(c.text)}, nil
}


Table <- "{" White tuples:TableElementList? White "}" {
  if tuples == nil {
    return TableNode{nil}, nil
  } else {
    return TableNode{tuples.([]TableTuple)}, nil
  }
}

TableElementList <- head:TableElement tail:TableElementTail* {
  tuples := make([]TableTuple, 0, 1)
  tuples = append(tuples, head.(TableTuple))
  for _, t := range tail.([]any) {
    tuples = append(tuples, t.(TableTuple))
  }

  return tuples, nil
}

TableElement <- el:(TableTuple / Expression) {
  switch el.(type) {
  case TableTuple:
    return el, nil
  default:
    // convert single value into table tuple
    return TableTuple{nil, el}, nil
  }
}

TableTuple <- name:(Name / TableTupleKeyExpression ) ":" White exp:Expression {
  return TableTuple{name, exp}, nil
}

TableTupleKeyExpression <- "[" White exp:Expression White "]" {
  return exp, nil
}

TableElementTail <- Space ("," / Break ) White el:TableElement {
  return el, nil
}

Chain <- target:(Ref / Parens) tail:ChainOperation+ {
  return ChainNode{target, tail.([]any)}, nil
}

ChainOperation <- ChainCall / ChainDot / ChainCallParens / ChainIndex

// whitespace function call
ChainCall <- SomeSpace args:ExpressionList {
  return ChainCallNode{args.([]any)}, nil
}

ChainCallParens <- "(" White args:ExpressionList White ")" {
  return ChainCallNode{args.([]any)}, nil
}

ChainDot <- "." White name:Name {
  return ChainDotNode{name.(string)}, nil
}

ChainIndex <- "[" White exp:Expression White "]" {
  return ChainIndexNode{exp}, nil
}

Indent <- [ \t]* {
  str := string(c.text)
  sum := 1 * strings.Count(str, " ") + 4 * strings.Count(str, "\t")
  return sum, nil
}

// measure the indent and only pass if it matches the current indent
MatchIndent <- indent:Indent &{
  if currentIndent(c.state) == indent.(int) {
    return true, nil
  }
  return false, nil
}


StartIndent <- indent:Indent &{
  if currentIndent(c.state) < indent.(int) {
    return true, nil
  }

  return false, nil
} #{
  pushIndent(c.state, indent.(int))
  return nil
}


PopIndent <- #{
  popIndent(c.state)
  return nil
}

InitialIndentLine <- StartIndent line:Line {
  return line, nil
}

IndentLine <- EmptyLine* MatchIndent line:Line {
  return line, nil
}

IndentLines <- EmptyLine* head:InitialIndentLine tail:IndentLine* PopIndent {
  lines := make([]any, 0, 1)
  lines = append(lines, head)
  for _, t := range tail.([]any) {
    lines = append(lines, t)
  }

  return lines, nil
}


IfStatement <- "if" Space condition:Expression Space lines:(ConditionLine / ConditionBlock) else_if_blocks:ElseIfBlock* else_lines:(ElseBlock / ElseLine)? {
  return IfStatementNode{
    condition,
    lines.([]any),
    toSlice[ElseIfStatementNode](else_if_blocks),
    toSlice[any](else_lines),
  }, nil
}

ConditionLine <- "then" Space line:Line {
  return []any{line}, nil
}

ConditionBlock <- Break lines:IndentLines {
  return lines, nil
}

ElseIfBlock <- "elseif" Space condition:Expression SpaceStop lines:IndentLines {
  return ElseIfStatementNode{condition, lines.([]any)}, nil
}

ElseBlock <- "else" SpaceStop lines:IndentLines {
  return lines, nil
}

ElseLine <- "else" Space line:Line {
  return []any{line}, nil
}

