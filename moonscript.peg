{
package main

}

Input <- lines:Line* EOF {
  outLines := make([]any, 0, len(lines.([]any)))

  for _, line := range lines.([]any) {
    if line == nil {
      continue
    }

    outLines = append(outLines, line)
  }

  return Lines{outLines}, nil
}


EOF <- !.
White <- [ \t\r\n]* // includes newlines
Space <- [ \t]*
SomeSpace <- [ \t]+
Break <- "\r"? "\n"
Stop <- Break / EOF

Line <- EmptyLine / CommentLine / AssignmentLine / ExpressionLine

EmptyLine <- (Space Break / [ \t]+ Stop) {
  return nil, nil
}

ExpressionLine <- value:Expression Stop {
  return value, nil
}

Expression <- head:ExpressionValue rest:OperatorExpression* {
  r := make([]OperatorExpressionNode, 0, len(rest.([]any)))

  for _, exp := range rest.([]any) {
    r = append(r, exp.(OperatorExpressionNode))
  }

  // remove unec
  if len(r) == 0 {
    return head, nil
  }

  return ExpressionNode{head, r}, nil
}

OperatorExpression <- Space operator:Operator White exp:ExpressionValue {
  return OperatorExpressionNode{operator.(string), exp}, nil
}

ExpressionValue <- Primitive / Number / Chain / Ref / String / Table / Parens

Parens <- "(" White exp:Expression White ")" {
  return ParensNode{exp}, nil
}

ExpressionList <- head:Expression tail:ExpressionListTail* {
  exprs := make([]any, 0, 1)
  exprs = append(exprs, head)
  for _, t := range tail.([]any) {
    exprs = append(exprs, t)
  }

  return exprs, nil
}

ExpressionListTail <- Space "," White expr:Expression {

  return expr, nil
}

Operator <- [-+*/^%<>] {
  return string(c.text), nil
}

AssignmentLine <- names:NameList White "=" White exprs:ExpressionList Stop {
  return AssignmentNode{names.([]any), exprs.([]any)}, nil
}

Comment <- "--" body:CommentBody {
  return CommentNode{body.(string)}, nil
}

// a comment that takes up an entire line
CommentLine <- Space value:Comment Stop {
  return value, nil
}

CommentBody <- (!Break .)* {
  return string(c.text), nil
}

Name <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

NameListTail <- Space "," White name:Name {
  return name, nil
}

NameList <- head:Name tail:NameListTail* {
  names := make([]any, 0, 1)
  names = append(names, head)
  for _, t := range tail.([]any) {
    names = append(names, t)
  }

  return names, nil
}

Ref <- name:Name {
  return RefNode{name.(string)}, nil
}

// TODO: handle decimals and exponents (non integer types
Number <- [0-9]+ {
  return NumberNode{Integer, string(c.text)}, nil
}

String <- DoubleQuotedString / SingleQuotedString / LuaString

DoubleQuotedString <- '"' parts:(Interpolation / DoubleStringChars)* '"' {
  return StringNode{`"`, parts.([]any)}, nil
}

DoubleStringChars <- ([\\] '"' / !["] !"#{" .)+ {
  return string(c.text), nil
}

Interpolation <- "#{" expr:Expression "}" {
  return InterpolationNode{expr}, nil
}

SingleQuotedString <- "'" parts:(SingleStringChars)* "'" {
  return StringNode{`'`, parts.([]any)}, nil
}

SingleStringChars <- ([\\] "'" / !"'" .)+ {
  return string(c.text), nil
}

LuaString <- LuaStringOpen parts:(LuaStringChars)* LuaStringClose {
  return StringNode{"XXX", parts.([]any)}, nil
}

LuaStringChars <- (!LuaStringClose .)+ {
  return string(c.text), nil
}

LuaStringDelimiterCount <- "="* {
  return len(c.text), nil
}

LuaStringOpen <- "[" count:LuaStringDelimiterCount "[" #{
  c.state["lua_string"] = count
  return nil
}

LuaStringClose <- "]" count:LuaStringDelimiterCount "]" &{
  if c.state["lua_string"].(int) == count.(int) {
    return true, nil
  }

  return false, nil
}

Primitive <- ("true" / "false" / "nil") {
  return PrimitiveNode{string(c.text)}, nil
}


Table <- "{" White tuples:TableElementList? White "}" {
  if tuples == nil {
    return TableNode{nil}, nil
  } else {
    return TableNode{tuples.([]TableTuple)}, nil
  }
}

TableElementList <- head:TableElement tail:TableElementTail* {
  tuples := make([]TableTuple, 0, 1)
  tuples = append(tuples, head.(TableTuple))
  for _, t := range tail.([]any) {
    tuples = append(tuples, t.(TableTuple))
  }

  return tuples, nil
}

TableElement <- el:(TableTuple / Expression) {
  switch el.(type) {
  case TableTuple:
    return el, nil
  default:
    // convert single value into table tuple
    return TableTuple{nil, el}, nil
  }
}

TableTuple <- name:(Name / TableTupleKeyExpression ) ":" White exp:Expression {
  return TableTuple{name, exp}, nil
}

TableTupleKeyExpression <- "[" White exp:Expression White "]" {
  return exp, nil
}

TableElementTail <- Space ("," / Break ) White el:TableElement {
  return el, nil
}

Chain <- target:(Ref / Parens) tail:ChainOperation+ {
  return ChainNode{target, tail.([]any)}, nil
}

ChainOperation <- ChainCall / ChainDot / ChainCallParens / ChainIndex

// whitespace function call
ChainCall <- SomeSpace args:ExpressionList {
  return ChainCallNode{args.([]any)}, nil
}

ChainCallParens <- "(" White args:ExpressionList White ")" {
  return ChainCallNode{args.([]any)}, nil
}

ChainDot <- "." White name:Name {
  return ChainDotNode{name.(string)}, nil
}

ChainIndex <- "[" White exp:Expression White "]" {
  return ChainIndexNode{exp}, nil
}


