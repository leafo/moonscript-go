{
package main

}

Input <- lines:Line* EOF {
  outLines := make([]any, 0, len(lines.([]any)))

  for _, line := range lines.([]any) {
    if line == nil {
      continue
    }

    // switch line := line.(type) {
    // case CommentNode:
    //   fmt.Println("This is a comment:", line.Text)
    // case NumberNode:
    //   fmt.Println("This is a number:", line.Text)
    // case RefNode:
    //   fmt.Println("This is a reference:", line.Name)
    // default:
    //   fmt.Printf("Unknown node type: %T: %v\n", line, line)
    //   continue
    // }

    outLines = append(outLines, line)
  }

  return Lines{outLines}, nil
}


EOF <- !.
White <- [ \t\r\n]* // includes newlines
Space <- [ \t]*
Break <- "\r"? "\n"
Stop <- Break / EOF

Line <- EmptyLine / CommentLine / AssignmentLine / ExpressionLine

EmptyLine <- (Space Break / [ \t]+ Stop) {
  return nil, nil
}

ExpressionLine <- value:Expression Stop {
  return value, nil
}

Expression <- Primitive / Number / Ref / String

AssignmentLine <- names:NameList White "=" White expr:Expression Stop {
  return AssignmentNode{names.([]any), expr}, nil
}

Comment <- "--" body:CommentBody {
  return CommentNode{body.(string)}, nil
}

// a comment that takes up an entire line
CommentLine <- Space value:Comment Stop {
  return value, nil
}

CommentBody <- (!Break .)* {
  return string(c.text), nil
}

Name <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

NameListTail <- Space "," White name:Name {
  return name, nil
}

NameList <- head:Name tail:NameListTail* {
  names := make([]any, 0, 1)
  names = append(names, head)
  for _, t := range tail.([]any) {
    names = append(names, t)
  }

  return names, nil
}

Ref <- name:Name {
  return RefNode{name.(string)}, nil
}

// TODO: handle decimals and exponents (non integer types
Number <- [0-9]+ {
  return NumberNode{Integer, string(c.text)}, nil
}

String <- DoubleQuotedString / SingleQuotedString / LuaString

DoubleQuotedString <- '"' parts:(Interpolation / DoubleStringChars)* '"' {
  return StringNode{`"`, parts.([]any)}, nil
}

DoubleStringChars <- ([\\] '"' / !["] !"#{" .)+ {
  return string(c.text), nil
}

Interpolation <- "#{" expr:Expression "}" {
  return InterpolationNode{expr}, nil
}

SingleQuotedString <- "'" parts:(SingleStringChars)* "'" {
  return StringNode{`'`, parts.([]any)}, nil
}

SingleStringChars <- ([\\] "'" / !"'" .)+ {
  return string(c.text), nil
}

LuaString <- LuaStringOpen parts:(LuaStringChars)* LuaStringClose {
  return StringNode{"XXX", parts.([]any)}, nil
}

LuaStringChars <- (!LuaStringClose .)+ {
  return string(c.text), nil
}

LuaStringDelimiterCount <- "="* {
  return len(c.text), nil
}

LuaStringOpen <- "[" count:LuaStringDelimiterCount "[" #{
  c.state["lua_string"] = count
  return nil
}

LuaStringClose <- "]" count:LuaStringDelimiterCount "]" &{
  if c.state["lua_string"].(int) == count.(int) {
    return true, nil
  }

  return false, nil
}

Primitive <- ("true" / "false" / "nil") {
  return PrimitiveNode{string(c.text)}, nil
}


